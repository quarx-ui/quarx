# Code Conventions

## Содержание
- [Типы компонентов](#типы-компонентов)
  - [main](#main)
  - [system](#system)
- [Базовая структура файлов компонента](#базовая-структура-файлов-компонента)
- [Именования](#именования)
- [Константные объекты вместо enum](#константные-объекты-вместо-enum)
  - [Пример константного объекта](#пример-константного-объекта)
  - [Создание константных объектов через функцию](#создание-константных-объектов-через-функцию)
  - [Union из значений константного объекта](#union-из-значений-константного-объекта)
  - [TypeGuard для константного объекта](#typeguard-для-константного-объекта)
- [Общие правила](#общие-правила)

## Типы компонентов
Компоненты в основном пакете дизайн-системы разделяются на следующие типы:

#### main
Основные компоненты, предназначенные для конечного пользователя. Должны иметь макеты в Figma и подробную
документацию в storybook.

#### system
Вспомогательные компоненты, которые используются для построения других компонентов. Они могут управлять
логикой появления на странице, анимацией, переходами и тд. Такие компоненты не представлены в Figma, но их можно
описать в storybook и экспортировать для конечного пользователя.

## Базовая структура файлов компонента

```yaml
ComponentName/
    __tests__/
        __snapshots__/            # генерируется автоматически, на основе тестов
        ComponentName.test.tsx    # тесты на jest

    stories/
        assets/                   # директория для вспомогательных файлов
        descriptions/             # описания для документации
        ComponentName.story.tsx   # документация

    styles/
        index.ts                  # файл со стилями
        types.ts                  # типизация стилей

    ComponentName.tsx             # основной код
    constants.ts                  # константы или константные объекты
    types.ts                      # типизация
    index.ts                      # экспорт компонента и его типов
```


## Именования

#### camelCase
Локальные переменные, функции, свойства, методы

Примеры:
```ts
const fooBar = 'baz';

const findSomething = () => { /* ... */ };

class Foo {
    awesomeProperty = 'hello';
    
    awesomeMethod = () => 'world';
}
```

<br/>

#### PascalCase
Классы, компоненты, типы, интерфейсы

Примеры:
```tsx
export class TimeFormatter { /* ... */ };

export const NavBar = () => (
    <div>{/* ... */}</div>
);

export type Side =
    | 'top'
    | 'left'
    | 'right'
    | 'bottom'

export interface NavBarProps {
    children?: ReactChild,
    className?: string,
}
```

<br/>

#### UPPER_CASE
Константы или константные объекты глобального назначения

Примеры:
```ts
export const FOO = 'bar';

export const COLORS = {
    main: 'main',
    secondary: 'secondary',
};
```

## Константные объекты вместо enum

Значения enum в typescript невозможно привести к другим типам данных, таким как константные строки
или объединения строк.

Если мы завяжем пропсы React-компонентов на внутренние enum-значения, то пользователям
библиотеки придется импортировать enum из нашего npm-пакета и использовать их для передачи пропсов,
иначе они будут получать ошибки typescript.

Это противоречит общепринятому паттерну передачи пропсов строкой,
поэтому мы приняли решение полностью отказаться от использования enum в коде библиотеки.

Вместо enum мы используем константные объекты в которых каждому ключу соответствует аналогичное значение.

### Пример константного объекта

Простой константный объект для замены enum выглядит так:
```ts
export const SIZE = {
    small: 'small',
    medium: 'medium',
    large: 'large',
} as const
```
Важную роль играет наличие `as const` – это позволяет строго типизировать значения, хранящиеся в объекте.

### Создание константных объектов через функцию

Для упрощения создания константных объектов добавлена вспомогательная функция `valuesAsKeysFromArray([...])`,
которая возвращает константный объект с указанными значениями:
```ts
export const SIZE = valuesAsKeysFromArray([
    'small',
    'medium',
    'large',
]);
```

### Union из значений константного объекта

Создание Union-типа из значений константного объекта возможно с помощью вспомогательного типа `Values<...>`:
```ts
export const SIZE = valuesAsKeysFromArray([
    'small',
    'medium',
    'large',
]);

export type Size = Values<typeof SIZE>; // 'small' | 'medium' | 'large'
```

### TypeGuard для константного объекта

Для некоторых переменных может требоваться проверка на соответствие нужному Union-типу. В typescript для этого
используются функции, которые проверяют переменную на соответствие нужному типу и возвращают `true` или `false`
([Type predicates](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)).

Для константных объектов мы можем создавать такие функции с помощью `createValuesAsKeysTypeGuard(CONST_OBJ)`:

```ts
export const SIZE = valuesAsKeysFromArray([
    'small',
    'medium',
    'large',
]);

export const isSize = createValuesAsKeysTypeGuard(SIZE);
```
Полученный в примере выше TypeGuard `isSize` можно применить в любом месте, где нужно проверить переменную
на соответствие значениям объекта `SIZE`:
```ts

let some: string

if (isSize(some)) { 
    /* some соответствует типу ('small' | 'medium' | 'large') */
} else {
    /* some соответствует типу string */
}
```

## Общие правила

- Если компонент использует `children`, его нужно явно указывать в интерфейсе пропсов, не полагаясь на типы-обертки
для компонентов, такие как тип `FC`
- Для добавления пропсов `ref` и `className` можно использовать наследование от вспомогательного интерфейса `BaseProps`
- Если пропсы одного компонента наследуются от другого, то нужно избегать наследования `classes`, `styles` и `cssVars`,
они должны быть уникальными для каждого компонента. Исключить их можно вспомогательным типом `OmitClassesAndStyles<Props>`
- В JSX-разметке не использовать конструкции `{ <condition> && ... }` и `{ <condition> ? ... : ... }`. Для замены этих
конструкций в библиотеке имеются системные компоненты `If` и `Switch`
