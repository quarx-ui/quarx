# Code Conventions

## Содержание
- [Типы компонентов](#типы-компонентов)
  - [main](#main)
  - [system](#system)
- [Базовая структура файлов компонента](#базовая-структура-файлов-компонента)
- [Именования](#именования)
- [Константные объекты вместо enum](#константные-объекты-вместо-enum)
  - [Пример константного объекта](#пример-константного-объекта)
  - [Создание константных объектов через функцию](#создание-константных-объектов-через-функцию)
  - [Union из значений константного объекта](#union-из-значений-константного-объекта)
  - [TypeGuard для константного объекта](#typeguard-для-константного-объекта)
- [Ограничения css псевдоклассов first-child и nth-child](#ограничения-css-псевдоклассов-first-child-и-nth-child)
- [Общие правила](#общие-правила)

## Типы компонентов
Компоненты в основном пакете дизайн-системы разделяются на следующие типы:

#### main
Основные компоненты, предназначенные для конечного пользователя. Должны иметь макеты в Figma и подробную
документацию в storybook.

#### system
Вспомогательные компоненты, которые используются для построения других компонентов. Они могут управлять
логикой появления на странице, анимацией, переходами и тд. Такие компоненты не представлены в Figma, но их можно
описать в storybook и экспортировать для конечного пользователя.

## Базовая структура файлов компонента

```yaml
ComponentName/
    __tests__/
        __snapshots__/            # генерируется автоматически, на основе тестов
        ComponentName.test.tsx    # тесты на jest

    stories/
        assets/                   # директория для вспомогательных файлов
        descriptions/             # описания для документации
        ComponentName.story.tsx   # документация

    styles/
        index.ts                  # файл со стилями
        types.ts                  # типизация стилей

    ComponentName.tsx             # основной код
    constants.ts                  # константы или константные объекты
    types.ts                      # типизация
    index.ts                      # экспорт компонента и его типов
```


## Именования

#### camelCase
Локальные переменные, функции, свойства, методы

Примеры:
```ts
const fooBar = 'baz';

const findSomething = () => { /* ... */ };

class Foo {
    awesomeProperty = 'hello';
    
    awesomeMethod = () => 'world';
}
```

<br/>

#### PascalCase
Классы, компоненты, типы, интерфейсы

Примеры:
```tsx
export class TimeFormatter { /* ... */ };

export const NavBar = () => (
    <div>{/* ... */}</div>
);

export type Side =
    | 'top'
    | 'left'
    | 'right'
    | 'bottom'

export interface NavBarProps {
    children?: ReactChild,
    className?: string,
}
```

<br/>

#### UPPER_CASE
Константы или константные объекты глобального назначения

Примеры:
```ts
export const FOO = 'bar';

export const COLORS = {
    main: 'main',
    secondary: 'secondary',
};
```

## Константные объекты вместо enum

Значения enum в typescript невозможно привести к другим типам данных, таким как константные строки
или объединения строк.

Если мы завяжем пропсы React-компонентов на внутренние enum-значения, то пользователям
библиотеки придется импортировать enum из нашего npm-пакета и использовать их для передачи пропсов,
иначе они будут получать ошибки typescript.

Это противоречит общепринятому паттерну передачи пропсов строкой,
поэтому мы приняли решение полностью отказаться от использования enum в коде библиотеки.

Вместо enum мы используем константные объекты в которых каждому ключу соответствует аналогичное значение.

### Пример константного объекта

Простой константный объект для замены enum выглядит так:
```ts
export const SIZE = {
    small: 'small',
    medium: 'medium',
    large: 'large',
} as const
```
Важную роль играет наличие `as const` – это позволяет строго типизировать значения, хранящиеся в объекте.

### Создание константных объектов через функцию

Для упрощения создания константных объектов добавлена вспомогательная функция `valuesAsKeysFromArray([...])`,
которая возвращает константный объект с указанными значениями:
```ts
export const SIZE = valuesAsKeysFromArray([
    'small',
    'medium',
    'large',
]);
```

### Union из значений константного объекта

Создание Union-типа из значений константного объекта возможно с помощью вспомогательного типа `Values<...>`:
```ts
export const SIZE = valuesAsKeysFromArray([
    'small',
    'medium',
    'large',
]);

export type Size = Values<typeof SIZE>; // 'small' | 'medium' | 'large'
```

### TypeGuard для константного объекта

Для некоторых переменных может требоваться проверка на соответствие нужному Union-типу. В typescript для этого
используются функции, которые проверяют переменную на соответствие нужному типу и возвращают `true` или `false`
([Type predicates](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)).

Для константных объектов мы можем создавать такие функции с помощью `createValuesAsKeysTypeGuard(CONST_OBJ)`:

```ts
export const SIZE = valuesAsKeysFromArray([
    'small',
    'medium',
    'large',
]);

export const isSize = createValuesAsKeysTypeGuard(SIZE);
```
Полученный в примере выше TypeGuard `isSize` можно применить в любом месте, где нужно проверить переменную
на соответствие значениям объекта `SIZE`:
```ts

let some: string

if (isSize(some)) { 
    /* some соответствует типу ('small' | 'medium' | 'large') */
} else {
    /* some соответствует типу string */
}
```


## Ограничения css псевдоклассов first-child и nth-child

В связи с использованием emotion в качестве стилевого движка дизайн-системы QuarX, необходимо учитывать особенности
[серверного рендеринга emotion-стилей](https://emotion.sh/docs/ssr).

Краткое описание проблемы:\
Без дополнительной конфигурации на сервере, emotion будет добавлять теги <style> в верстку, располагая их над блоками,
к которым эти стили относятся. Пример SSR-рендеринга с использованием emotion:

```html
<!--No SSR-->
<div class="container">
  <div class="css-lgj0h8">Element 1</div>
  <div class="css-k008qs">Element 2</div>
</div>
```

```html
<!--SSR-->
<div class="container">
  <style data-emotion="css lgj0h8">...</style>
  <div class="css-lgj0h8">Element 1</div>
  
  <style data-emotion="css k008qs">...</style>
  <div class="css-k008qs" >Element 2</div>
</div>
```

Такое поведение накладывает ограничения на использование псевдоклассов `:nth-child` и `:first-child`, так как
теги `<style>` будут учитываться при подсчёте элементов. По этой причине рекомендуется избегать использования указанных
псевдоклассов и прибегать к другим селекторам, которые описаны ниже. Стоит отметить, что на псевдокласс `:last-child`
ограничения не распространяются.

### :first-child

На примере выше видно, что при обращении по селектору `.container > :first-child` в случае SSR будет выбран
первый тег `<style>`, а не первый `<div>`. В данном случае возможны 2 замены, которые могут обеспечить правильное поведение:

#### :first-of-type
Рекомендуется, если все элементы в контейнере относятся к одному типу (имеют одинаковый тег). В примере выше
все элементы контейнера имеют тег `<div>`, поэтому можно воспользоваться селектором:
```css
.container > :first-of-type {}
```

#### style и :not(style)

Возможны ситуации, в которых элементами контейнера являются разные теги, например:

```html
<!--No SSR-->
<div class="container">
  <div class="css-lgj0h8">Element 1</div>
  <div class="css-kq03b1">Element 2</div>
  <a class="css-k008qs">Element 3</a>
</div>
```

```html
<!--SSR-->
<div class="container">
  <style data-emotion="css lgj0h8">...</style>
  <div class="css-lgj0h8">Element 1</div>
  
  <style data-emotion="css kq03b1">...</style>
  <div class="css-kq03b1">Element 2</div>
  
  <style data-emotion="css k008qs">...</style>
  <a class="css-k008qs" >Element 3</a>
</div>
```

В таком случае использование псевдокласса `:first-of-type` выберет не только первый встреченный `<div>`, но и `<a>`.
Чтобы этого избежать, можно обратиться к первому тегу `<style>` и выбрать следующий за ним элемент:
`style:first-child + *`. Также необходимо помнить, что тег `<style>` может отсутствовать, поэтому селектор также должен
обрабатывать случай, когда первый элемент не является тегом `<style>`. Конечная версия селектора выглядит так:
```css
.container > style:first-child + *, .container > :not(style):first-child {}
```

### :nth-child

Замена селектора `:nth-child` возможна только с помощью селектора `:nth-of-type` и только в том случае,
когда элементы контейнера представлены одинаковыми тегами.

### :last-child

Псевдокласс `:last-child` можно применять без ограничений, так как вставка тега `<style>` всегда происходит выше
блока, к которому этот `<style>` относится.

## Общие правила

- Если компонент использует `children`, его нужно явно указывать в интерфейсе пропсов, не полагаясь на типы-обертки
для компонентов, такие как тип `FC`
- Для добавления пропсов `ref` и `className` можно использовать наследование от вспомогательного интерфейса `BaseProps`
- Если пропсы одного компонента наследуются от другого, то нужно избегать наследования `classes`, `styles` и `cssVars`,
они должны быть уникальными для каждого компонента. Исключить их можно вспомогательным типом `OmitClassesAndStyles<Props>`
- В JSX-разметке не использовать конструкции `{ <condition> && ... }` и `{ <condition> ? ... : ... }`. Для замены этих
конструкций в библиотеке имеются системные компоненты `If` и `Switch`
